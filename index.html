<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>陈广宵的网络日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="陈广宵的网络日志">
<meta property="og:url" content="http://www.xbroder.com/index.html">
<meta property="og:site_name" content="陈广宵的网络日志">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="陈广宵的网络日志">
  
    <link rel="alternate" href="/atom.xml" title="陈广宵的网络日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xbroder.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">陈广宵的网络日志</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">

  
    <article id="post-小狗钱钱笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/小狗钱钱笔记/" class="article-date">
  <time datetime="2018-07-21T14:19:58.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/理财/">理财</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/小狗钱钱笔记/">小狗钱钱笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <ul>
<li><p>不是试试看，而是去切实行动！如果你只是抱着试试看的心态，那么你之后以失败告终，你会一事无成。“尝试”纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择 – 做或者不做。</p>
</li>
<li><p>是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。</p>
</li>
<li><p>你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本你相信你自己能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。</p>
</li>
<li><p>成功日记：每天把所有做成功的事情记录进去。你最好每天都做这件事，每次都写至少5条你的个人成果，任何小事都可以。开始的时候也许你觉得不太容易，可能会问自己，这件或那件事情是否真的可以算是成果。在这种情况下你的回答应该是肯定的。过于自信总比没有自信好得多。</p>
</li>
<li><p>过于自信总比不自信好得多。</p>
</li>
<li><p>第一，为别人解决一个难题，那么你就能赚到许多钱：第二：把精力集中在你知道的、能做的和拥有的东西上。</p>
</li>
<li><p>许多人总爱犯这样的错误：他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。</p>
</li>
<li><p>首先：遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候做出最杰出的表现。</p>
</li>
<li><p>你的喜悦让你忘记了该做的事情。你看，有成千上万的事情可能让你分心，因此你每天应该在固定的时间里，有规律地做这些事情。</p>
</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2018/07/21/小狗钱钱笔记/" data-id="cjjvk74tg001g8cs68s6pxs6j" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理财/">理财</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-理财小白的入门课" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/理财小白的入门课/" class="article-date">
  <time datetime="2018-07-11T03:46:51.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/理财/">理财</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/理财小白的入门课/">理财小白的入门课</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>先列出一些培养财商的书单，读完非常有感触，下次会出一些相关的读书笔记</p>
<h3 id="《小狗钱钱》"><a href="#《小狗钱钱》" class="headerlink" title="《小狗钱钱》"></a>《小狗钱钱》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN9QFicffPibVHjPtj0nFJc3SaUmK1DV1ebs39mOibxhymVgSQn5MmfLUibeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《小狗钱钱》"></p>
<h3 id="《富爸爸，穷爸爸》"><a href="#《富爸爸，穷爸爸》" class="headerlink" title="《富爸爸，穷爸爸》"></a>《富爸爸，穷爸爸》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN99C0y5MhENWGXicCkwWLKhib4GiaXZOwM3bqQ2ribADqyu1Dclk4Nj7Pfag/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《富爸爸，穷爸爸》"></p>
<h3 id="《财报就像一本故事书》"><a href="#《财报就像一本故事书》" class="headerlink" title="《财报就像一本故事书》"></a>《财报就像一本故事书》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN9f0kBAcuo7Sm7VrsicgjljA1icDsCjyOpfwoApLrlQCvdgZjBjkXwzA6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《财报就像一本故事书》"></p>
<h3 id="《世界上最简单的会计书》"><a href="#《世界上最简单的会计书》" class="headerlink" title="《世界上最简单的会计书》"></a>《世界上最简单的会计书》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN9JMETCfkJXd1cxP7Kic6Ku561XZCfJCgjshJric7wBE86cYKRficuDdObQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《世界上最简单的会计书》"></p>
<h3 id="《聪明的投资者》"><a href="#《聪明的投资者》" class="headerlink" title="《聪明的投资者》"></a>《聪明的投资者》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN9eLwUnIQzhoC7l9ODlqzMiaSayl1kf9U04IRUibeGnicgtS0zLkwJQf1gQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《聪明的投资者》"></p>
<h3 id="《巴菲特的护城河》"><a href="#《巴菲特的护城河》" class="headerlink" title="《巴菲特的护城河》"></a>《巴菲特的护城河》</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/9nNmSy5D1FbgcAvEEPonb5WlaDatPVN9mM2ibZroJgMAbK4Jqb2Poaq827DicvmscmwY4HU4BHURQkkt43Ud6LJQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="《巴菲特的护城河》"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2018/07/11/理财小白的入门课/" data-id="cjjvk74ts001x8cs62rbmcnmy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理财/">理财</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-如何在疲劳的JS世界中持续学习？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/如何在疲劳的JS世界中持续学习？/" class="article-date">
  <time datetime="2018-07-11T03:46:51.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/如何在疲劳的JS世界中持续学习？/">如何在疲劳的JS世界中持续学习？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="关注业界前端大牛"><a href="#关注业界前端大牛" class="headerlink" title="关注业界前端大牛"></a>关注业界前端大牛</h3><ul>
<li>关注大牛及其github作品等等，微博，twitter等等。阮一峰老师，justjavac，狼叔，四月，月影，尤雨溪等等</li>
<li>经常follow他们，还有JavaScript社区的领袖们，CNode的狼叔了解下</li>
<li>经常关注github，关注业界顶级的项目</li>
</ul>
<h3 id="持续关注和探索页面的项目"><a href="#持续关注和探索页面的项目" class="headerlink" title="持续关注和探索页面的项目"></a>持续关注和探索页面的项目</h3><ul>
<li>Github的Explore，里面有很多Topics、Resource、Trending repositories</li>
</ul>
<h3 id="看最好的资讯"><a href="#看最好的资讯" class="headerlink" title="看最好的资讯"></a>看最好的资讯</h3><ul>
<li>奇舞周刊</li>
<li><a href="web-design-weekly.com">Web Design Weekly</a></li>
<li><a href="esnextnews.com">ES.next News</a></li>
<li><a href="frontendfront.com">Front-End Front</a></li>
<li><a href="medium.com/dailyjs">DailyJS</a></li>
<li><a href="www.echojs.com">EchoJS</a></li>
<li><a href="https://cnodejs.org/" target="_blank" rel="noopener">CNODE</a></li>
<li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎Live</a></li>
</ul>
<h3 id="源码源码源码"><a href="#源码源码源码" class="headerlink" title="源码源码源码"></a>源码源码源码</h3><p>源码源码，拒绝无耻搬砖，当伸手党</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://medium.com/@alonronin/stay-updated-in-js-fatigue-universe-3bf5c0d671a4" target="_blank" rel="noopener">Stay updated in JS fatigue universe</a></li>
<li><a href="https://uptodate.frontendrescue.org/" target="_blank" rel="noopener">HOW TO KEEP UP TO DATE ON  FRONT-END TECHNOLOGIE</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36339128" target="_blank" rel="noopener">如何在疲劳的JS世界中持续学习</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2018/07/11/如何在疲劳的JS世界中持续学习？/" data-id="cjjvk74ti001k8cs6b8vqfo1r" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-现代JS框架存在的根本原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/04/现代JS框架存在的根本原因/" class="article-date">
  <time datetime="2018-06-04T15:05:11.000Z" itemprop="datePublished">2018-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/现代JS框架存在的根本原因/">现代JS框架存在的根本原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><strong>【本文转载自 奇舞周刊 微信公众号】</strong></p>
<p>我曾见过很多很多人盲目地使用（前端）框架，如 React，Angular 或 Vue等等。这些框架提供了许多有意思的东西，然而通常人们（自以为）使用框架是因为：</p>
<ul>
<li>它们支持组件化；</li>
<li>它们有强大的社区支持；</li>
<li>它们有很多（基于框架的）第三方库来解决问题；</li>
<li>它们有很多（很好的）第三方组件;</li>
<li>它们有浏览器扩展工具来帮助调试；</li>
<li>它们适合做单页应用。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tiapMh3yNSjT3YSdLWh9FFhCibOEdzevK3v4gRsQ3pwmgKibMdX9j1pofpg/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>但这些都不是使用框架的根本原因。</p>
<p>最最本质的原因是：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tiahLqstvVxftIiakQcIX9Fpujq6JVMvzxQyS63q6q9icRnzk1EiagfsK2xA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>（UI 与状态同步非常困难）</p>
<h2 id="是的，就是这原因，让我们来看看为什么"><a href="#是的，就是这原因，让我们来看看为什么" class="headerlink" title="是的，就是这原因，让我们来看看为什么"></a>是的，就是这原因，让我们来看看为什么</h2><p>假设你正在设计这样一个 Web 应用：用户可以通过群发电子邮件来邀请其他人（参加某活动）。UX/UI 设计师设计如下：（在用户填写任何邮箱地址之前，）有一个空白状态，并为此添加一些帮助信息；（当用户填写邮箱之后，）展示邮箱的地址，每个地址的右侧均有一个按钮用于删除对应的地址。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tiaoaU3nnzrphgqDspErIADltUUIkqcSVaQcUtM3nvjxcSLGz0BBBowMQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>这个表单的状态，可以被设计为一个数组，里面包含若干对象，对象由邮箱地址和唯一标识组成。开始的时候，数组为空。当（用户）输入邮箱地址并按下回车键之后，往数组中添加一项并更新 UI。当用户点击删除按钮时，删除（数组中对应的）邮箱地址并更新 UI。你感觉到了吗？每当你改变状态时，你都需要更新 UI。</p>
<p>（你可能会说：）那又怎样？好吧，让我们看看如何在不用框架的情况下实现它：</p>
<h2 id="用原生（JS）实现相对复杂的-UI"><a href="#用原生（JS）实现相对复杂的-UI" class="headerlink" title="用原生（JS）实现相对复杂的 UI"></a>用原生（JS）实现相对复杂的 UI</h2><p>以下代码很好地说明了使用原生 JavaScript 实现一个相对复杂的 UI 所需的工作量，使用像  jQuery 这样经典的库也需要差不多的工作量。</p>
<p>在这个例子中，HTML 负责创建静态页面，JavaScript 通过 <code>document.createElement</code> 动态改变（DOM 结构）。这引来了第一个问题：构建 UI 相关的 JavaScript 代码并不直观易读，我们将 UI 构建分为了两部分（译者注：应该是指 HTML与 JavaScript 两部分）。尽管我们使用了 <code>innerHTML</code>，可读性是增强了，但降低了（页面的）性能，同时可能存在 CSRF 漏洞。我们也可以使用模板引擎，但如果是大面积地修改 DOM，会面临两个问题：效率不高与需要重新绑定事件处理器。</p>
<p>但这也不是（不使用框架的）最大问题。最大的问题是 <strong>每当状态发生改变时都要（手动）更新 UI</strong> 。每次状态更新时，都需要很多代码来改变 UI。当添加电子邮件地址时，只需要两行代码来更新状态，但要十三行代码更新 UI。（此例中）我们已经让 UI （界面与逻辑）尽可能简单了！！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tiaeYA8HkaRPxeIJe7G9TDricSzPQlLicPzWo9WiaSrgv20wrgiazg2TxQ7aw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>代码既难写又难理解，更麻烦的是它非常脆弱。假设我们需要（添加）同步服务器数据到邮件地址列表的功能，我们需要对比服务器返回结果与数组中数据的差异。这涉及对比所有数据的标识与内容，（当用户修改后，）可能需要在内存中保留一份标识相同但内容不同的数据。</p>
<p>为了高效地改变 DOM，我们需要编写大量点对点（译者注：指状态到 UI）的代码。<strong>但只要你犯下了很小的错误，UI 与状态将不再保持同步：</strong>（可能会出现）丢失或呈现错误的信息、不再响应用户的操作，更糟糕的是触发了错误的动作（如点了删除按钮后删除了非对应的一项）。</p>
<p>因此，保持 UI 与状态同步，需要编写大量乏味且非常脆弱的代码。</p>
<h2 id="响应式-UI-拯救一切"><a href="#响应式-UI-拯救一切" class="headerlink" title="响应式 UI 拯救一切"></a>响应式 UI 拯救一切</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tia7jq3Pl9sCUwpq4N37tFfN3mEfJGHmGHUFcCNWJwENxlDCTQEXIc1Ow/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>所以，（之所以使用框架，）不是因为社区，不是因为工具，不是因为生态，不是因为第三方库……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前为止，框架最大的改进是（为我们）提供了应用内部状态与 UI 同步的可靠保证。</span><br></pre></td></tr></table></figure>
<p>只要你清楚特定框架的某些（特定）规则（如不可变状态），就差不多（可以正常使用）了。</p>
<p><strong>我们只需要定义一次 UI 界面，不再需要为每个操作编写特定的 UI 代码，同时，每个相同的状态均有相同的输出（译者注：指 UI 一致）：</strong>当状态改变后，框架自动更新（对应的）视图。</p>
<h2 id="框架是如何工作的呢"><a href="#框架是如何工作的呢" class="headerlink" title="框架是如何工作的呢?"></a>框架是如何工作的呢?</h2><p>基于两个基本的策略：</p>
<ul>
<li><p>重新渲染整个组件，如React。当组件中的状态发生改变时，在内存中计算出（新的）DOM 结构后与已有的 DOM 结构进行对比。实际上，这是非常昂贵的。因而采取（将真实 DOM）映射为虚拟 DOM ，通过对比状态变化前后虚拟 DOM 的不同，计算出变化后再改变真实 DOM 结构。这个过程称为调和（reconciliation）。</p>
</li>
<li><p>通过（添加）观察者监测变化，如 Angular 和 Vue.js。应用中状态的属性会被监测，当它们发生变化时，只有依赖了（发生变化）属性的 DOM 元素会被重新渲染。</p>
</li>
</ul>
<h2 id="那-Web-components-呢"><a href="#那-Web-components-呢" class="headerlink" title="那 Web components 呢?"></a>那 Web components 呢?</h2><p>很多时候，人们会把 React、 Angular 和 Vue.js （等框架）与 Web components 进行对比。这显然体现了人们并不理解这些框架所提供的最大好处：保持 UI 与状态同步。Web components 并不提供这种同步机制。它仅仅提供了一个\标签，但它不提供任何（状态与 UI 之间的）协调机制。<strong>如果你在应用中使用 Web components 时，想保持 UI 与内部状态同步，则需要（开发者）手工完成，或者使用如 Stencil.js (内部和 React一样，使用虚拟 DOM)之类的库。</strong></p>
<p>让我们明确一点：框架表现出的巨大潜力并不体现在组件化上，保持 UI 与状态同步才是具体的体现。Web components 并未提供相关的功能，你必须手工或使用第三方库去解决（同步的）问题。使用原生 JavaScript 去编写复杂、高效且易于维护的 UI 界面基本上是不可能的。<strong>这就是你需要使用现代 JavaScript 框架的根本原因。</strong></p>
<h2 id="自己动手，丰衣足食"><a href="#自己动手，丰衣足食" class="headerlink" title="自己动手，丰衣足食"></a>自己动手，丰衣足食</h2><p>如果热衷于了解底层原理，想知道虚拟 DOM 的具体实现。那，为何不试着在不使用框架的情况下，仅使用虚拟 DOM 来重写原生 UI呢？</p>
<p>这里是框架的核心，所有组件的基础类。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tiaWK03oaKQ5dERI5nvat5miaPHGaWsATm4zNjGWP91D5hxq9vIJGbPsDA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>这里是重写后的 AddressList 组件（借助 babel 来支持 JSX 的转换）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib6GG6Sc1ZOGEIJic6Y21ia3tias3EN6vcN2cPIrqFwLgbbvzaiadnknbsoq5rCbI2YKibMvbIicrUf50wicQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p><strong>现在 UI 是声明式的</strong>，我们并未使用任何框架。我们能任意添加新逻辑来改变状态的同时，不需要编写额外的代码来保持 UI 同步。问题解决了！</p>
<p>现在，除了事件处理之外，这看起来就像个 React 应用对吧？我们有<code>haverender()</code> 、<code>componentDidMount()</code> 、<code>setState()</code> 等等。一旦解决了保持应用内 UI 与状态的同步问题，所有东西就会很自然地叠加起来（形成组件）。</p>
<p>可以在这个 Github (<a href="https://github.com/gimenete/ui-state-sync" target="_blank" rel="noopener">https://github.com/gimenete/ui-state-sync</a>) 仓库中找到完整的源代码。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>现代 js 框架解决的主要问题是保持 UI 与状态同步。</li>
<li>使用原生 JavaScript 编写复杂、高效而又易于维护的 UI 界面几乎是不可能的。</li>
<li>Web components 并未提供解决同步问题的方案。</li>
<li>使用现有的虚拟 DOM 库去搭建自己的框架并不困难。但并不建议这么做！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2018/06/04/现代JS框架存在的根本原因/" data-id="cjjvk74tq001s8cs634na1jg4" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-京东入职篇章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/12/京东入职篇章/" class="article-date">
  <time datetime="2017-07-12T12:38:23.000Z" itemprop="datePublished">2017-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/随笔/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/12/京东入职篇章/">京东入职新篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前两天终于从<code>乐视体育</code>离职了，持续很长一段时间的<code>乐视风波</code>，对我而言，算是结束了，有些不舍，有些不服。</p>
<p>即将要开始在<code>京东商城</code>的刷副本升级旅程了。</p>
<p>不舍在于，多少也呆了差不多一年，交了好多好同事，虽然同事都陆陆续续早已离职，高就<code>小米</code>、<code>滴滴</code>、<code>美团</code>了。</p>
<p>很多人都坚信老贾终有一天王者归来…希望有这一天吧</p>
<p>一阵风吹来，希望能吹起新的篇章吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2017/07/12/京东入职篇章/" data-id="cjjvk74tc001d8cs60j7hb9bh" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-C-环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/23/C-环境搭建/" class="article-date">
  <time datetime="2017-06-23T15:24:12.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/23/C-环境搭建/">C++ IDE环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="IDE-安装"><a href="#IDE-安装" class="headerlink" title="IDE 安装"></a>IDE 安装</h2><ul>
<li>地址：<a href="https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3DBr-A1cBQWPuLQDGbqf6Tot2cF24jxeH8L-LbAYA1qTOEMDq_DfeSz9qhwlYew3eR%26wd%3D%26eqid%3D863098390001e2b3000000025b4f6e36ss" target="_blank" rel="noopener">IDE 下载安装地址</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2017/06/23/C-环境搭建/" data-id="cjjvk74rv00008cs6bcm3rv1g" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-如何正确学习C++" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/23/如何正确学习C++/" class="article-date">
  <time datetime="2017-06-23T13:24:12.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/23/如何正确学习C++/">如何正确学习C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这里首先分享一个北京大学的C++公开课 - 《程序设计学习ACM》，<a href="https://pan.baidu.com/s/1YDHwcPeveUOIsmKHox7YPQ" target="_blank" rel="noopener">百度网盘地址</a></p>
<p>之所以决定开始学习 C++, 是因为 Node 的底层是基于 C++，所以决定开始学习 C++，以便深入 Node。</p>
<h2 id="C-的应用"><a href="#C-的应用" class="headerlink" title="C++ 的应用"></a>C++ 的应用</h2><ul>
<li>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</li>
<li>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</li>
<li>Node、Android 等底层都是 C++编写</li>
<li>嵌入式、游戏编程、网络编程、系统编程</li>
</ul>
<h2 id="C-特点"><a href="#C-特点" class="headerlink" title="C++ 特点"></a>C++ 特点</h2><ul>
<li>快：运算速度快</li>
<li>省：节省资源，能够降低硬件成本</li>
</ul>
<h2 id="与C语言的关系"><a href="#与C语言的关系" class="headerlink" title="与C语言的关系"></a>与C语言的关系</h2><ul>
<li>C 是 C++ 的子集：拿着 C 的代码放到 C++ 的 IDE 环境下编辑，完全没有问题</li>
<li>从 C语言的基础上发展过来的</li>
<li>C 面向过程</li>
<li>C++ 支持面向过程 + 支持面向对象</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>语言基础，参考<a href="https://www.zhihu.com/question/38828701" target="_blank" rel="noopener">C++ Primer 第五版</a></li>
<li>安装Visual Studio IDE</li>
<li><a href="https://wizardforcel.gitbooks.io/w3school-cpp/content/index.html" target="_blank" rel="noopener">W3School C++ 基础教程</a></li>
<li><a href="https://www.imooc.com/course/list?c=cplusplus" target="_blank" rel="noopener">C++ 慕课视频</a></li>
<li><a href="https://www.imooc.com/course/list?c=c" target="_blank" rel="noopener">C语言 慕课视频</a></li>
</ul>
<p>test push </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2017/06/23/如何正确学习C++/" data-id="cjjvk74tk001l8cs6m9etegva" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-V8入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/V8入门/" class="article-date">
  <time datetime="2017-05-24T14:11:32.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/V8引擎/">V8引擎</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/V8入门/">Chrome V8引擎入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Chrome V8引擎是基于 C++ 语言编写的项目。学习 V8 引擎需要对 C++ 有一个初步的认识。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/v8/v8" target="_blank" rel="noopener">github 地址</a></li>
<li><a href="https://github.com/v8/v8/wiki" target="_blank" rel="noopener">V8 Wiki</a></li>
<li><a href="https://chromium.googlesource.com/v8/v8.git" target="_blank" rel="noopener">V8 Git仓库的官方镜像</a></li>
<li><a href="https://v8docs.nodesource.com/" target="_blank" rel="noopener">V8 文档</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2017/05/24/V8入门/" data-id="cjjvk74t800168cs63fr8rkrf" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Nginx的Gzip配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/29/Nginx的Gzip配置/" class="article-date">
  <time datetime="2016-12-29T15:02:24.000Z" itemprop="datePublished">2016-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/29/Nginx的Gzip配置/">Nginx的Gzip设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Gzip配置参数"><a href="#Gzip配置参数" class="headerlink" title="Gzip配置参数"></a>Gzip配置参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gzip配置的常用参数</span><br><span class="line">gzip on|off;  #是否开启gzip</span><br><span class="line">gzip_buffers 32 4K| 16 8K #缓冲(压缩在内存中缓冲几块? 每块多大?)</span><br><span class="line">gzip_comp_level [1-9] #推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源)</span><br><span class="line">gzip_disable #正则匹配UA 什么样的Uri不进行gzip</span><br><span class="line">gzip_min_length 200 # 开始压缩的最小长度(再小就不要压缩了,意义不在)</span><br><span class="line">gzip_http_version 1.0|1.1 # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)</span><br><span class="line">gzip_proxied          # 设置请求者代理服务器,该如何缓存内容</span><br><span class="line">gzip_types text/plain  application/xml # 对哪些类型的文件用压缩 如txt,xml,html ,css</span><br><span class="line">gzip_vary on|off  # 是否传输gzip压缩标志 Vary是用来标志缓存的依据.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>注意:</span><br><span class="line"><span class="meta">#</span>图片/mp3这样的二进制文件,不必压缩</span><br><span class="line"><span class="meta">#</span>因为压缩率比较小, 比如100-&gt;80字节,而且压缩也是耗费CPU资源的.</span><br><span class="line"><span class="meta">#</span>比较小的文件不必压缩,</span><br></pre></td></tr></table></figure>
<p><strong>思考:</strong></p>
<ul>
<li>如果2个人,一个浏览器支持gzip,一个浏览器不支持gzip2个同时请求同个页面, chinaCache缓存压缩后,还是未压缩的?</li>
<li>如果1人,再次请求页面,chinaCache返回压缩后的缓存内容,还是压缩前的缓存内容?</li>
</ul>
<p>这个时候 Vary的作用体现出来.即——缓存的内容受 Accept-Encoding头信息的影响.  </p>
<p>所以如果<br>请求时,不支持gzip, 缓存服务器将会生成一份未gzip的内容.<br>请求时,支持gzip, 缓存服务器将会生成一份gzip的内容.  </p>
<p>下次再请求时, 缓存服务器会考虑客户端的Accept-Encoding因素,并合理的返回信息  </p>
<p>Nginx对于图片,js等静态文件的缓存设置<br>注:这个缓存是指针对浏览器所做的缓存,不是指服务器端的数据缓存.  </p>
<p>主要知识点: location expires指令  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(jpg|jpeg|png|gif)$ &#123;</span><br><span class="line">    expires 1d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.js$ &#123;</span><br><span class="line">    expires 1h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置并载入新配置文件,用firebug观察,<br>会发现 图片内容,没有再次产生新的请求,原因–利用了本地缓存的效果.  </p>
<p><strong>注: 在大型的新闻站,或文章站中,图片变动的可能性很小,建议做1周左右的缓存Js,css等小时级的缓存.</strong></p>
<p>如果信息流动比较快,也可以不用expires指令,<br>用last_modified, etag功能(主流的web服务器都支持这2个头信息)  </p>
<p>原理是:<br>响应: 计算响应内容的签名, etag 和 上次修改时间<br>请求: 发送 etatg, If-Modified-Since 头信息.<br>服务器收到后,判断etag是否一致, 最后修改时间是否大于if-Modifiled-Since<br>如果监测到服务器的内容有变化,则返回304,<br>浏览器就知道,内容没变,直接用缓存.  </p>
<p><strong>304 比起上面的expires 指令多了1次请求,但是比200状态,少了传输内容.</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Nginx官网, <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">Nginx Gzip Module</a></li>
<li>Nginx官网, <a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html" target="_blank" rel="noopener">Nginx Gzip Static Module</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2016/12/29/Nginx的Gzip配置/" data-id="cjjvk74s9000a8cs6f30adjop" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Nginx做负载均衡器以及proxy缓存配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/29/Nginx做负载均衡器以及proxy缓存配置/" class="article-date">
  <time datetime="2016-12-29T15:02:24.000Z" itemprop="datePublished">2016-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/29/Nginx做负载均衡器以及proxy缓存配置/">Nginx做负载均衡器以及proxy缓存配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="nginx-sticky-module"><a href="#nginx-sticky-module" class="headerlink" title="nginx-sticky-module"></a>nginx-sticky-module</h2><p>本文主要是完成一下几个功能</p>
<ul>
<li>结合proxy和upstream模块实现nginx负载均衡</li>
<li>结合nginx_upstream_check_module模块实现后端服务器的健康检查</li>
<li>使用nginx-sticky-module扩展模块实现Cookie会话黏贴（session-sticky效果）</li>
<li>使用proxy模块实现静态文件缓存</li>
<li>使用ngx_cache_purge实现更强大的缓存清除功能</li>
</ul>
<p>项目地址 <a href="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng" target="_blank" rel="noopener">https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng</a>  </p>
<p>这个模块的作用是通过cookie黏贴的方式将来自同一个客户端（浏览器）的请求发送到同一个后端服务器上处理，这样一定程度上可以解决多个backend servers的session同步的问题 —— 因为不再需要同步，而RR轮询模式必须要运维人员自己考虑session同步的实现。  </p>
<p>另外内置的 ip_hash 也可以实现根据客户端IP来分发请求，但它很容易造成负载不均衡的情况，而如果nginx前面有CDN网络或者来自同一局域网的访问，它接收的客户端IP是一样的，容易造成负载不均衡现象。淘宝Tengine的 ngx_http_upstream_session_sticky_module 也是类似的功能。nginx-sticky-module的cookie过期时间，默认浏览器关闭就过期，也就是会话方式。  </p>
<p>这个模块并不合适不支持 Cookie 或手动禁用了cookie的浏览器，此时默认sticky就会切换成RR。它不能与ip_hash同时使用。  </p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/nginx-lb-sticky.jpg" alt="img1">  </p>
<h3 id="sticky配置"><a href="#sticky配置" class="headerlink" title="sticky配置"></a>sticky配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 语法</span><br><span class="line"><span class="meta">#</span> sticky [name=route] [domain=.foo.bar] [path=/] [expires=1h] [hash=index|md5|sha1] [no_fallback]</span><br><span class="line"><span class="meta">#</span> name: 可以为任何的 string 字符,默认是 route</span><br><span class="line"><span class="meta">#</span> domain：哪些域名下可以使用这个 cookie</span><br><span class="line"><span class="meta">#</span> path：哪些路径对启用 sticky，例如 path/test，那么只有 test 这个目录才会使用 sticky 做负载均衡</span><br><span class="line"><span class="meta">#</span> expires：cookie 过期时间，默认浏览器关闭就过期，也就是会话方式。</span><br><span class="line"><span class="meta">#</span> no_fallbackup：如果设置了这个，cookie 对应的服务器宕机了，那么将会返回502（bad gateway 或者 proxy error），建议不启用</span><br><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.1.100:8080 weight=1;</span><br><span class="line">    server 192.168.1.101:8080 weight=1;</span><br><span class="line">    sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置起来超级简单，一般来说一个sticky指令就够了。  </p>
<p>你在查看官方文档可能会注意到里面也有个 sticky 指令，要说它们的作用几乎是一样的，但是你可能注意到This directive is available as part of our commercial subscription.的说明 —— 这是nginx商业版本里才有的特性。包括后面的check指令，在nginx的商业版本里也有对应的health_check（配在 location ）实现几乎一样的监控检查功能。  </p>
<h3 id="load-balance其它调度方案"><a href="#load-balance其它调度方案" class="headerlink" title="load-balance其它调度方案"></a>load-balance其它调度方案</h3><p>这里顺带介绍一下nginx的负载均衡模块支持的其它调度算法：</p>
<ul>
<li>轮询（默认） ： 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight 指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash ： 每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。当然如果这个节点不可用了，会发到下个节点，而此时没有session同步的话就注销掉了。</li>
<li>least_conn ： 请求被发送到当前活跃连接最少的realserver上。会考虑weight的值。</li>
<li>url_hash ： 此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包 nginx_upstream_hash 。</li>
<li>fair ： 这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的 upstream_fair 模块。</li>
</ul>
<h2 id="负载均衡与健康检查"><a href="#负载均衡与健康检查" class="headerlink" title="负载均衡与健康检查"></a>负载均衡与健康检查</h2><p>严格来说，nginx自带是没有针对负载均衡后端节点的健康检查的，但是可以通过默认自带的 ngx_http_proxy_module 模块和 ngx_http_upstream_module 模块中的相关指令来完成当后端节点出现故障时，自动切换到下一个节点来提供访问。  </p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> weight ： 轮询权值也是可以用在ip_hash的，默认值为1</span><br><span class="line"><span class="meta">#</span> max_fails ： 允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</span><br><span class="line"><span class="meta">#</span> fail_timeout ： 有两层含义，一是在 30s 时间内最多容许 2 次失败；二是在经历了 2 次失败以后，30s时间内不分配请求到这台服务器。</span><br><span class="line"><span class="meta">#</span> backup ： 预留的备份机器。当其他所有的非backup机器出现故障的时候，才会请求backup机器，因此这台机器的压力最轻。（为什么我的1.6.3版本里配置backup启动nginx时说invalid parameter "backup"？）</span><br><span class="line"><span class="meta">#</span> max_conns： 限制同时连接到某台后端服务器的连接数，默认为0即无限制。因为queue指令是commercial，所以还是保持默认吧。</span><br><span class="line"><span class="meta">#</span> proxy_next_upstream ： 这个指令属于 http_proxy 模块的，指定后端返回什么样的异常响应时，使用另一个realserver</span><br><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.1.101:8080:8080 weight 2;</span><br><span class="line">    server 192.168.1.101:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server 192.168.1.102:8080 backup;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx-upstream-check-module"><a href="#nginx-upstream-check-module" class="headerlink" title="nginx_upstream_check_module"></a>nginx_upstream_check_module</h2><p>nginx_upstream_check_module 是专门提供负载均衡器内节点的健康检查的外部模块，由淘宝的姚伟斌大神开发，通过它可以用来检测后端 realserver 的健康状态。如果后端 realserver 不可用，则后面的请求就不会转发到该节点上，并持续检查几点的状态。在淘宝自己的 tengine 上是自带了该模块。项目地址  </p>
<p><a href="https://github.com/yaoweibin/nginx_upstream_check_module" target="_blank" rel="noopener">https://github.com/yaoweibin/nginx_upstream_check_module</a>  </p>
<p>下面的是一个带后端监控检查的 nginx.conf 配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line"><span class="meta">	#</span> interval ： 向后端发送的健康检查包的间隔。</span><br><span class="line"><span class="meta">	#</span> fall ： 如果连续失败次数达到fall_count，服务器就被认为是down。</span><br><span class="line"><span class="meta">	#</span> rise ： 如果连续成功次数达到rise_count，服务器就被认为是up。</span><br><span class="line"><span class="meta">	#</span> timeout ： 后端健康请求的超时时间。</span><br><span class="line"><span class="meta">	#</span> default_down ： 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。默认值是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。</span><br><span class="line"><span class="meta">	#</span> type：健康检查包的类型，现在支持以下多种类型</span><br><span class="line"><span class="meta">		#</span> tcp：简单的tcp连接，如果连接成功，就说明后端正常。</span><br><span class="line"><span class="meta">		#</span> http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活。</span><br><span class="line"><span class="meta">		#</span> ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活。</span><br><span class="line"><span class="meta">		#</span> ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包。</span><br><span class="line"><span class="meta">		#</span> mysql: 向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活。</span><br><span class="line"><span class="meta">		#</span> fastcgi：发送一个fastcgi请求，通过接受解析fastcgi响应来判断后端是否存活</span><br><span class="line"><span class="meta">	#</span> port: 指定后端服务器的检查端口。你可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，表示跟后端server提供真实服务的端口一样。该选项出现于Tengine-1.4.0。</span><br><span class="line">    sticky;     # or simple round-robin</span><br><span class="line">    server 192.168.1.101:8080 weight=2;</span><br><span class="line">    server 192.168.1.101:8081 weight=1 max_fails=2 fail_timeout=30s ;</span><br><span class="line">    server 192.168.1.102:8080 weight=1 max_fails=2 fail_timeout=30s ;</span><br><span class="line">    server 192.168.1.102:8081;</span><br><span class="line">    </span><br><span class="line">    check interval=5000 rise=2 fall=3 timeout=1000 type=http;</span><br><span class="line">    check_http_send "HEAD / HTTP/1.0\r\n\r\n";</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">    location /status &#123;</span><br><span class="line">        check_status;</span><br><span class="line">        access_log   off;</span><br><span class="line">        allow 172.29.73.23;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面配置的意思是，对name这个负载均衡条目中的所有节点，每个5秒检测一次，请求2次正常则标记 realserver状态为up，如果检测 3 次都失败，则标记 realserver的状态为down，超时时间为1秒。  </p>
<p>check指令只能出现在upstream中  </p>
<p>如果 type 为 http ，你还可以使用check_http_send来配置http监控检查包发送的请求内容，为了减少传输数据量，推荐采用 HEAD 方法。当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，如： HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n 。当采用 GET 方法的情况下，请求uri的size不宜过大，确保可以在1个interval内传输完成，否则会被健康检查模块视为后端服务器或网络异常。  </p>
<p>check_http_expect_alive指定HTTP回复的成功状态，默认认为 2XX 和 3XX 的状态是健康的。  </p>
<h2 id="Nginx的proxy缓存使用"><a href="#Nginx的proxy缓存使用" class="headerlink" title="Nginx的proxy缓存使用"></a>Nginx的proxy缓存使用</h2><p>nginx的页面缓存功能与上面的负载均衡和健康检查是没有关系的，放在这里一是因为懒得再起一篇文章，二是再有load-balance的地方一般都会启用缓存的。  </p>
<p>缓存也就是将js、css、image等静态文件从tomcat缓存到nginx指定的缓存目录下，既可以减轻tomcat负担，也可以加快访问速度，但这样缓存及时清理成为了一个问题，所以需要 ngx_cache_purge 这个模块来在过期时间未到之前，手动清理缓存。（这里有篇 文章，对比使用缓存、不使用缓存、使用动静分离三种情况下，高并发性能比较。使用代理缓存功能性能会高出很多倍）  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> proxy_temp_path ： 缓存临时目录。后端的响应并不直接返回客户端，而是先写到一个临时文件中，然后被rename一下当做缓存放在 proxy_cache_path 。0.8.9版本以后允许temp和cache两个目录在不同文件系统上（分区），然而为了减少性能损失还是建议把它们设成一个文件系统上。</span><br><span class="line"><span class="meta">#</span> proxy_cache_path ... ： 设置缓存目录，目录里的文件名是 cache_key 的MD5值。levels=1:2 keys_zone=cache_one:50m表示采用2级目录结构，Web缓存区名称为cache_one，内存缓存空间大小为100MB，这个缓冲zone可以被多次使用。文件系统上看到的缓存文件名类似于 /usr/local/nginx-1.6/proxy_cache/c/29/b7f54b2df7773722d382f4809d65029c 。inactive=2d max_size=2g表示2天没有被访问的内容自动清除，硬盘最大缓存空间为2GB，超过这个大学将清除最近最少使用的数据。</span><br><span class="line"><span class="meta">#</span> proxy_cache ： 引用前面定义的缓存区 cache_one</span><br><span class="line"><span class="meta">#</span> proxy_cache_key ： 定义cache_key</span><br><span class="line"><span class="meta">#</span> proxy_cache_valid ： 为不同的响应状态码设置不同的缓存时间，比如200、302等正常结果可以缓存的时间长点，而404、500等缓存时间设置短一些，这个时间到了文件就会过期，而不论是否刚被访问过。</span><br><span class="line"><span class="meta">#</span> expires ： 在响应头里设置Expires:或Cache-Control:max-age，返回给客户端的浏览器缓存失效时间。</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ... // $upstream_cache_status记录缓存命中率</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"'</span><br><span class="line">                      '"$upstream_cache_status"';</span><br><span class="line"></span><br><span class="line">    proxy_temp_path   /usr/local/nginx-1.6/proxy_temp;</span><br><span class="line">    proxy_cache_path /usr/local/nginx-1.6/proxy_cache levels=1:2 keys_zone=cache_one:100m inactive=2d max_size=2g;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80; </span><br><span class="line">        server_name  ittest.example.com;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm index.jsp;</span><br><span class="line"></span><br><span class="line">        location ~ .*\.(gif|jpg|png|html|css|js|ico|swf|pdf)(.*) &#123;</span><br><span class="line">            proxy_pass  http://backend;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header   X-Real-IP   $remote_addr;</span><br><span class="line">            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            proxy_cache cache_one;</span><br><span class="line">            add_header Nginx-Cache $upstream_cache_status;</span><br><span class="line">            proxy_cache_valid  200 304 301 302 8h;</span><br><span class="line">            proxy_cache_valid 404 1m;</span><br><span class="line">            proxy_cache_valid  any 2d;</span><br><span class="line">            proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ /purge(/.*) &#123;</span><br><span class="line">            #设置只允许指定的IP或IP段才可以清除URL缓存。</span><br><span class="line">            allow   127.0.0.1;</span><br><span class="line">            allow   172.29.73.0/24;</span><br><span class="line">            deny    all;</span><br><span class="line">            proxy_cache_purge  cache_one $host$1$is_args$args;</span><br><span class="line">            error_page 405 =200 /purge$1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于缓存的失效期限上面有三个选项：X-Accel-Expires、inactive、proxy_cache_valid、expires，它们之间是有优先级的，按上面的顺序如果在header里设置 X-Accel-Expires 则它的优先级最高，否则inactive优先级最高。更多资料请参考 nginx缓存优先级 或这里。</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/nginx-cache-hit.png" alt="http://7q5fot.com1.z0.glb.clouddn.com/nginx-cache-hit.png"></p>
<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><p>上述配置的proxy_cache_purge指令用于方便的清除缓存，但必须按照第三方的 ngx_cache_purge 模块才能使用，项目地址:<br><a href="https://github.com/FRiCKLE/ngx_cache_purge" target="_blank" rel="noopener">https://github.com/FRiCKLE/ngx_cache_purge</a>  </p>
<p>使用 ngx_cache_purge 模块清除缓存有2种办法（直接删除缓存目录下的文件也算一种办法）：</p>
<ul>
<li>echo发送PURGE指令: proxy_cache_purge PURGE from 127.0.0.1表示只允许在来自本地的清除指令</li>
<li>GET方式请求URL: 即使用配置文件中的location ~ /purge(/.*)，浏览器访问<a href="http://ittest.example.com/purge/your/may/path来清除缓存，或者echo" target="_blank" rel="noopener">http://ittest.example.com/purge/your/may/path来清除缓存，或者echo</a> -e ‘GET /purge/ HTTP/1.0\r\n’ | nc ittest.example.com 80  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e 'PURGE / HTTP/1.0\r\n' | nc 127.0.0.1 80</span><br></pre></td></tr></table></figure>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/nginx-cache-purge.png" alt="http://7q5fot.com1.z0.glb.clouddn.com/nginx-cache-purge.png">  </p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>official documentation, <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">official documentation</a></li>
<li>Nginx实战系列之功能篇—-后端节点健康检查, <a href="http://nolinux.blog.51cto.com/4824967/1594029" target="_blank" rel="noopener">Nginx实战系列之功能篇—-后端节点健康检查</a></li>
<li>Tengine, <a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">Tengine nginx_upstream_check_module</a></li>
<li>nginx反向代理tomcat集群做负载均衡缓存, <a href="http://quenlang.blog.51cto.com/4813803/1570352" target="_blank" rel="noopener">nginx反向代理tomcat集群做负载均衡缓存</a></li>
<li>web内容缓存 nginx高性能缓存详解, <a href="http://www.ttlsa.com/nginx/nginx-high-performance-caching/" target="_blank" rel="noopener">web内容缓存 nginx高性能缓存详解</a></li>
<li>使用nginx sticky实现基于cookie的负载均衡, <a href="http://www.ttlsa.com/nginx/nginx-modules-nginx-sticky-module/" target="_blank" rel="noopener">使用nginx sticky实现基于cookie的负载均衡</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xbroder.com/2016/12/29/Nginx做负载均衡器以及proxy缓存配置/" data-id="cjjvk74s600058cs66wb0exsz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/giscafer" target="_blank" title="Github"></a>
      
      
            <a class="weibo" aria-hidden="true"  href="http://weibo.com/laohoubin" target="_blank" title="微博"></a>
      
      
              <a class="zhihu" aria-hidden="true"  href="http://www.zhihu.com/people/giscafer" target="_blank" title="知乎"></a>
      
      
            <a class="email" aria-hidden="true"  href="mailto:youemail@outlook.com" target="_blank" title="邮箱"></a>
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/V8引擎/">V8引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/理财/">理财</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 14px;">C++</a> <a href="/tags/JavaScript/" style="font-size: 19.5px;">JavaScript</a> <a href="/tags/Nginx/" style="font-size: 25px;">Nginx</a> <a href="/tags/理财/" style="font-size: 14px;">理财</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/21/小狗钱钱笔记/">小狗钱钱笔记</a>
          </li>
        
          <li>
            <a href="/2018/07/11/理财小白的入门课/">理财小白的入门课</a>
          </li>
        
          <li>
            <a href="/2018/07/11/如何在疲劳的JS世界中持续学习？/">如何在疲劳的JS世界中持续学习？</a>
          </li>
        
          <li>
            <a href="/2018/06/04/现代JS框架存在的根本原因/">现代JS框架存在的根本原因</a>
          </li>
        
          <li>
            <a href="/2017/07/12/京东入职篇章/">京东入职新篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
        <ul>
            
            <li>
                <a href="http://blog.giscafer.com">giscafer&#39;s blog</a>
            </li>
            
            <li>
                <a href="http://www.gis520.com">GIS520社区</a>
            </li>
            
        </ul>
    </div>
</div>

  
    <!--微信公众号二维码-->

  <div class="widget-wrap">
    <h3 class="follow-title ">WeChat</h3>
    <div class="widget wechat-widget">
        <img src="http://blog.giscafer.com/static/images/qrcode_giscafer.jpg" alt="扫码关注" width="250"/>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 陈广宵&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;youemail@outlook.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>