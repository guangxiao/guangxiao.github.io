---
layout: post
title: Node 学习笔记05 - 异步I/O
date: 2018-11-08 21:55:15
tags: Node
categories: Node
---

异步I/O 和事件驱动和单线程，构成 Node 的基调。最初 Ryan Dahl 期望设计出一个高性能的 Web 服务器，后来演变成一个可以基于它构建各种高速、可伸缩网络应用的平台。

与 Node 事件驱动、异步 I/O 设计理念比较相近的是 Nginx。Nginx 采用 C 编写。性能表现非常优异。区别在于，Nginx 具备面向客户端管理连接的能力，但是背后依然受限于各种同步方式的编程语言。

Node 却是全方位的，即可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。

## 一、为什么要异步I/O

可以从用户体验和资源分配两方面分析

**用户体验**

假如一个资源来自于两个不同位置的数据返回，第一个资源需要 M 毫秒的耗时，第二个资源需要 N 毫秒的耗时。

如果采用同步的方式
```js
// 消费时间为 M
getData('from_db')
// 消费时间为 N
getData('from_remote_api')
```

如果采用异步的方式
```js

getData('from_db', (result) => {
    // 消费时间为 M    
})

getData('from_remote_api', (result) => {
    // 消费时间为 N
})
```

对比两者的时间总消耗，同步为 M+N，异步为 max(M, N)

随着应用场景的复杂性的增加，情景会变成 M + N + ... 和 max(M, N, ...)

**资源分配**

假如业务场景中有一组互不相关的任务需要完成，现行的主流方法有

> - 单线程串行依次执行
> - 多线程并行

但是这样子会面临以下缺点

> - 单线程同步编程模型会因阻塞 I/O 而导致硬件资源得不到更优的使用
> - 多线程编程模型一因为编程中的死锁、状态同步等问题让开发人员头疼

Node 在两者之间给出了答案

> - 利用单线程，远离多线程的死锁、状态同步问题
> - 利用异步 I/O 让单线程远离阻塞，以更好的利用 CPU

为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器的 Web Worker 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/0。


## 二、异步 I/O 的现状

异步/同步，阻塞/非阻塞 实际上是两回事。异步并不等于非阻塞。

> -  阻塞 I/O：调用之后一定要等到系统内核层面完成所有的操作后，调用才结束。造成了 CPU 等待 I/O，浪费等待时间，CPU 的处理能力得不到充分利用。
> - 非阻塞 I/O：非阻塞I/O 和阻塞I/O 区别在于调用之后立即返回，而且是不带数据直接返回。由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态，为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。这种技术叫轮询

**轮询**

现存的轮询技术有以下几种

> - read
> - select
> - poll
> - epoll
> - kqueue

## 三、Node 的异步 I/O

Node 的执行模型是事件循环。完成整个异步 I/O 环节的有事件循环、观察者和请求对象。

**关键词**
> - Tick: 在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们称为 Tick。
> - 观察者
> - 事件循环：典型的生产者/消费者的模型
> - 请求对象
> - I/O 线程池

事件循环、观察者、请求对象、I/O 线程池 构成了 Node 异步 I/O 模型的基本要素。


## 四、非 I/O 的异步API

> - 定时器 setTimeout(), setInterval()
> - process.nextTick()
> - setImmediate()









